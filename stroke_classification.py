# -*- coding: utf-8 -*-
"""Stroke_classification.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1klKfgg1jElQiii2FLB8ETBDmyIjAit_u
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.preprocessing import LabelEncoder
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.svm import SVC
from sklearn import svm
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, classification_report, confusion_matrix

import warnings
warnings.filterwarnings("ignore")

df = pd.read_csv('healthcare-dataset-stroke-data.csv')

df.head()

df.info()

df.describe()

df.duplicated().sum()

"""**data cleaning**"""

df.drop(['id'], axis = 1, inplace = True)

df.isna().sum()

df['bmi'].fillna(df['bmi'].mean() , inplace=True)

df.isna().sum().sum()

"""**check for outliers**"""

df_numeric = df.select_dtypes(include = [np.number])

Q1 = df_numeric.quantile(0.25)
Q3 = df_numeric.quantile(0.75)
IQR = Q3 - Q1

lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

df_numeric_mean_replaced = df_numeric.copy()
for col in df_numeric.columns:
    mean = df_numeric[col].mean()
    df_numeric_mean_replaced[col] = np.where(
        (df_numeric[col] < lower_bound[col]) | (df_numeric[col] > upper_bound[col]),
        mean,
        df_numeric[col]
    )

df[df_numeric.columns] = df_numeric_mean_replaced

df.head()

"""**Encoding and Scaling**"""

lb = LabelEncoder()
for col in df.select_dtypes('object').columns:
    df[col] = lb.fit_transform(df[col])

x = df.drop(['stroke'], axis = 1)
y = df['stroke']

scaler = StandardScaler()
x = scaler.fit_transform(x)

corr_matrix = df.corr()

plt.figure(figsize=(8, 6))
sns.heatmap(corr_matrix, annot=True, fmt=".2f", cmap='coolwarm', linewidths=0.5, vmax=1, vmin=-1)
plt.title("Correlation Heatmap of Features")
plt.tight_layout()
plt.show()

"""**Splitting the data**"""

from sklearn.preprocessing import LabelEncoder

# Encode labels
label_encoder = LabelEncoder()
y = label_encoder.fit_transform(y)

x_train, x_test, y_train, y_test = train_test_split(x, y, test_size = 0.2, random_state = 42)

"""# **SVM Model buliding**"""

svm_model = SVC(kernel='linear', random_state=42)

svm_model.fit(x_train, y_train)

y_pred = svm_model.predict(x_test)

accuracy = accuracy_score(y_test, y_pred)
precision = precision_score(y_test, y_pred, average='weighted')
recall = recall_score(y_test, y_pred, average='weighted')
f1 = f1_score(y_test, y_pred, average='weighted')

# Print metrics
print(f"Accuracy: {accuracy:.2f} %")
print(f"Precision: {precision:.2f} %")
print(f"Recall: {recall:.2f} %")
print(f"F1 Score: {f1:.2f} %")

# Detailed classification report
print("\nClassification Report for SVM:")
print(classification_report(y_test, y_pred))

conf_matrix = confusion_matrix(y_test, y_pred)

plt.figure(figsize=(5, 5))

sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues',
            xticklabels=['0','1'], yticklabels=['0','1'])
plt.xlabel('Predicted')
plt.ylabel('True')
plt.title('Confusion Matrix Heatmap')

plt.tight_layout()
plt.show()

"""# **Random Forest Model buliding**"""

# Random Forest Model
from sklearn.ensemble import RandomForestClassifier
rf_model = RandomForestClassifier(random_state=42)

rf_model.fit(x_train, y_train)

y_pred_rf = rf_model.predict(x_test)

accuracy_rf = accuracy_score(y_test, y_pred_rf)
precision_rf = precision_score(y_test, y_pred_rf, average='weighted')
recall_rf = recall_score(y_test, y_pred_rf, average='weighted')
f1_rf = f1_score(y_test, y_pred_rf, average='weighted')

# Print metrics
print(f"Accuracy: {accuracy_rf:.2f} %")
print(f"Precision: {precision_rf:.2f} %")
print(f"Recall: {recall_rf:.2f} %")
print(f"F1 Score: {f1_rf:.2f} %")

# Detailed classification report
print("\nClassification Report for Random Forest Model:")
print(classification_report(y_test, y_pred_rf))

conf_matrix = confusion_matrix(y_test, y_pred_rf)

plt.figure(figsize=(5, 5))

sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues',
            xticklabels=['0','1'], yticklabels=['0','1'])
plt.xlabel('Predicted')
plt.ylabel('True')
plt.title('Confusion Matrix Heatmap')

plt.tight_layout()
plt.show()

"""# **KNN Model Building**"""

knn_model = KNeighborsClassifier()

knn_model.fit(x_train, y_train)

y_pred_knn = knn_model.predict(x_test)

# Evaluation metrics for KNN
accuracy_knn = accuracy_score(y_test, y_pred_knn)
precision_knn = precision_score(y_test, y_pred_knn, average='weighted')
recall_knn = recall_score(y_test, y_pred_knn, average='weighted')
f1_knn = f1_score(y_test, y_pred_knn, average='weighted')

# Print metrics
print(f"Accuracy: {accuracy_knn:.2f} %")
print(f"Precision: {precision_knn:.2f} %")
print(f"Recall: {recall_knn:.2f} %")
print(f"F1 Score: {f1_knn:.2f} %")

print("\nClassification Report for KNN Model:")
print(classification_report(y_test, y_pred_knn))

conf_matrix_knn = confusion_matrix(y_test, y_pred_knn)
plt.figure(figsize=(5, 5))
sns.heatmap(conf_matrix_knn, annot=True, fmt='d', cmap='Blues', xticklabels=['0', '1'], yticklabels=['0', '1'])
plt.xlabel('Predicted')
plt.ylabel('True')
plt.title('KNN Confusion Matrix Heatmap')
plt.tight_layout()
plt.show()

# Print comparison of accuracies
print(f"Accuracy of SVM: {accuracy:.2f}%")
print(f"Accuracy of Random Forest: {accuracy_rf:.2f}%")
print(f"Accuracy of KNN: {accuracy_knn:.2f}%")

# Plot comparison of accuracies
models = list(model_accuracies.keys())
accuracies = list(model_accuracies.values())

plt.figure(figsize=(6, 4))
sns.barplot(x=models, y=accuracies, palette='viridis')
plt.xlabel('Model')
plt.ylabel('Accuracy')
plt.title('Comparison of Model Accuracies')
plt.ylim(0, 1)  # Set y-axis limits to show the accuracy range (0 to 1)
plt.show()